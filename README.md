# Аналог Я.Диска

## Общая информация

Проект представляет собой упрощённый аналог Яндекс.Диска, реализованный в виде микросервисной архитектуры.
Система поддерживает регистрацию и аутентификацию пользователей, управление папками, загрузку, скачивание, поиск и удаление файлов.

Все сервисы взаимодействуют между собой по HTTP через единый API Gateway и разворачиваются в Docker-контейнерах.

---

## Архитектура

Тип архитектуры микросервисная

Проект реализован в виде набора независимых микросервисов, каждый из которых отвечает за свою зону ответственности.
Внешний доступ осуществляется только через Nginx и API Gateway.

---

## Микросервисы

### api-gateway

Единая точка входа в систему.
Отвечает за

 маршрутизацию HTTP-запросов к внутренним сервисам
 retry-логику
 circuit breaker
 fallback-ответы
 проверку доступности сервисов

### auth-service

Сервис аутентификации и авторизации.

 регистрация пользователей
 логин
 выдача JWT-токенов
  Использует `user-service` для работы с данными пользователей.

### user-service

Сервис управления пользователями.

 хранение и обработка данных пользователей (id, email, username, password hash и т.д.)
 работа с PostgreSQL

### file-data-service

Сервис метаданных файлов и папок.

 имя
 путь
 владелец
 размер
 тип
 parent_id
 временные метки
  Физические файлы не хранит.

### file-storage-service

Сервис приёма и отдачи файлов.

 загрузка
 скачивание
 удаление файлов
  Физическое хранение файлов осуществляется в MinIO.

---

## Вспомогательные компоненты

### PostgreSQL

Основная реляционная база данных.
Используется для хранения

 пользователей
 файлов
 папок
 иерархии директорий (через parent_id)

### Redis

Используется для

 управления процессом загрузки файлов
 временных состояний
 блокировок
 контроля повторных загрузок

### MinIO

S3-совместимое объектное хранилище.
Используется как файловое хранилище проекта.

### Kafka

Используется для асинхронной обработки событий.
Пример успешная загрузка файла.

### Zookeeper

Используется Kafka для управления брокером и метаданными.

### Nginx

Внешняя точка входа.
Принимает HTTP-трафик и проксирует его в api-gateway.

---

## Сетевая модель

 Все микросервисы доступны только внутри Docker-сети
 Внешний доступ осуществляется исключительно через цепочку

Nginx → api-gateway → внутренние сервисы

---

## Выбор хранилищ

### PostgreSQL

Используется для хранения пользователей, файлов и папок.
Иерархия папок реализована через поле `parent_id`.

### Redis

Используется для управления процессом загрузки файлов и временного хранения состояния.

### MinIO

Выбран из-за поддержки S3 API и возможности масштабирования.

Принцип хранения файлов

```
storage_key = bucketuser_idfile_id
```

---

## Асинхронность через Kafka

При загрузке файла используется асинхронная обработка событий.

Сценарий

1. file-storage-service принимает файл
2. после успешной загрузки публикуется событие `file.uploaded`
3. file-data-service подписан на этот топик и создаёт запись в PostgreSQL

Используемый топик

 `file.uploaded`

---

## Отказоустойчивость

В api-gateway реализованы следующие механизмы.

### Retry

 Повторы выполняются при сетевых ошибках
 Только для методов без тела запроса (GET, HEAD)
 Максимум 3 попытки
 Задержки 100 мс → 200 мс → 500 мс
 POST и PUT не повторяются

### Circuit Breaker

 Срабатывает после 2 подряд сетевых ошибок
 Блокирует запросы к сервису на 30 секунд

### Fallback

Возвращаемый JSON

```
{
  error true,
  msg Service temporarily unavailable,
  service service_name,
  retry_in 30,
  fallback true
}
```

HTTP-коды

 503 — при сетевой ошибке
 429 — при срабатывании circuit breaker

### Timeout

Все межсервисные HTTP-вызовы ограничены таймаутом 60 секунд
Настроено через `proxy.Balancer.Timeout`.

---

## REST API (через api-gateway)

### Аутентификация

 POST apiv1authregister
 POST apiv1authlogin

### Папки

 GET apiv1folders
 POST apiv1folders
 DELETE apiv1folders{id}
 GET apiv1folderstree{id}

### Файлы

 POST apiv1file
 GET apiv1file{id}
 DELETE apiv1file{id}
 GET apiv1files{id}
 GET apiv1filesfile={mask}

---

## Docker Compose

Все сервисы разворачиваются с помощью docker-compose.

Основные сервисы

 api-gateway
 auth-service
 user-service
 file-data-service
 file-storage-service
 nginx
 postgres
 redis
 minio
 kafka
 zookeeper

Также используются контейнеры инициализации и миграций

 user-migrate
 filedata_migrate
 kafka-init
 minio-init

Все сервисы объединены в Docker-сеть `disknet`.
Используются healthcheck’и для корректного порядка запуска.

---

## Сборка и запуск проекта

Для управления проектом используется Makefile.

### Доступные команды

```
make deps
make tidy
make tests
make lint
make lint-fix
make build
make up
make down
```

Ок, вот установочный гайд на русском, в Markdown (`.md`) формате, аккуратно и профессионально, чтобы можно было просто скопировать и вставить в README.md и чтобы форматирование корректно отображалось в GitLab.

Ты можешь вставить этот раздел в начале README, например после краткого описания проекта.

---

## Установка и запуск проекта

Исходный код проекта доступен в GitLab-репозитории

GitLab
[https://gitlab.crja72.ru/golang/2025/autumn/projects/go/36/disk](https://gitlab.crja72.ru/golang/2025/autumn/projects/go/36/disk)

Ниже приведена пошаговая инструкция по установке и запуску проекта локально.

### Требования

Перед началом убедитесь, что у вас установлены

 Git
 Docker
 Docker Compose
 Make
 Go (версия, совместимая с проектом)
 jq (для выполнения примеров curl-запросов)

### Клонирование репозитория

Склонируйте репозиторий и перейдите в директорию проекта

```
git clone httpsgitlab.crja72.rugolang2025autumnprojectsgo36disk.git
cd disk
```

### Установка зависимостей

Загрузите все Go-зависимости для сервисов проекта

```
make deps
```

### Приведение go.mod в актуальное состояние

```
make tidy
```

### Запуск тестов

Перед запуском рекомендуется выполнить все unit-тесты

```
make tests
```

### Сборка и запуск проекта

Для сборки Docker-образов и запуска всех сервисов выполните

```
make build
```

Команда

 собирает Docker-образы всех микросервисов
 поднимает инфраструктуру (PostgreSQL, Redis, MinIO, Kafka, Zookeeper, Nginx)
 запускает миграции
 ожидает прохождения healthcheck для сервисов

### Повторный запуск без пересборки

Если образы уже собраны, можно запустить проект без пересборки

```
make up
```

### Остановка проекта

Для остановки и удаления всех контейнеров

```
make down
```

### Проверка доступности

После успешного запуска

 внешний доступ осуществляется через Nginx
 все HTTP-запросы идут через api-gateway
 сервисы доступны только внутри Docker-сети `disknet`

После этого проект готов к использованию и тестированию через REST API.

### Рекомендуемый порядок запуска

1. Убедиться, что установлены Docker и Docker Compose
2. Выполнить команду

```
make build
```

3. Дождаться, пока все сервисы пройдут healthcheck
4. Использовать API через Nginx и api-gateway

### Как пользоваться API через Swagger UI

1. **Откройте Swagger UI**
   Перейдите по адресу:

   ```
   http://localhost:<NGINX_PORT>/docs/
   ```

2. **Попробовать эндпоинт**

   * Нажмите на интересующий эндпоинт → **Try it out**
   * Заполните форму запроса (JSON или параметры URL)
   * Нажмите **Execute** → увидите ответ API и HTTP-код

3. **Авторизация через JWT**

   * Сначала зарегистрируйтесь `/auth/register` или войдите `/auth/login`
   * Полученный токен вставьте в поле **Authorize** в верхнем правом углу
   * После этого все защищённые эндпоинты будут доступны

4. **Ответы и ошибки**

   * Код `200` или `201` — успешно
   * Код `400` — ошибка в запросе
   * Код `401` — неавторизованный
   * Код `503` или `429` — сервис временно недоступен
